Computer Networks Major Task Weight: 25% (course project) | Group size: 4–6 students | Submission: LMS (one submission per group) 1. Learning Outcomes By completing this project, students will be able to: • Design a compact application-layer protocol satisfying concrete requirements. • Implement client-server (and where applicable, peer-to-peer) applications using sockets. • Instrument code and run controlled experiments (delay/loss/jitter) and analyze results. • Write an RFC-like protocol specification and a reproducible technical report. • Work effectively in teams and communicate technical results professionally. 2. High-level Expectations & Constraints 1. Primary transport must be UDP for the custom protocol (TCP may be used only for administrative control channels if justified). 2. Your code must be cross-platform: it should run on Linux and Windows with minimal changes (Python 3 recommended). 3. Provide scripts to run the experiments reproducibly; use deterministic seeds when randomization is involved. 4. Log all sent/received packets with timestamps and relevant metadata; include pcap traces for at least two runs per test scenario. 5. Repeat each measurement at least 5 times; report median and range (min/median/max) and explain observed variance. 3. Application-Layer Protocols (Each group must choose one project): Project 1: IoT Telemetry Protocol (Sensor Reporting) In this project, you will design and implement a custom lightweight telemetry protocol for constrained IoT sensors that periodically send small readings (e.g., temperature, humidity, or voltage) to a central collector. Your goal is to design a compact, efficient, and robust application-layer protocol operating over UDP, and to evaluate its performance under varying network conditions experimentally.  1. Functional Requirements 1.1 Core Design Your protocol must: 
• Use UDP as its transport layer. • Support at least two message types: o DATA: carries one or more sensor readings. o HEARTBEAT: sent periodically when no new data is available, to indicate device liveness. • Not use per-packet retransmission (loss-tolerant by design). • Use a compact binary header (≤ 12 bytes recommended). • Support an optional batching mode, where multiple readings (up to N) are grouped into a single packet. • Include in each message: o Device ID o Sequence number o Timestamp o Message type o Optional fields (chosen by your team, e.g., flags, checksum, etc.) Each group defines its own protocol name (e.g., TinyTelemetry v1), version, and header format. The header layout and encoding must be fully documented in your Mini-RFC.  1.2 Server Responsibilities Your collector (server) must: • Maintain per-device state (e.g., last sequence number, timestamps). • Perform duplicate suppression (ignore repeated sequence numbers). • Detect and report sequence gaps when packets are lost. • Reorder delayed packets by timestamp for analysis. • (For measurement purposes) Log all received data to a CSV file with fields: device_id, seq, timestamp, arrival_time, duplicate_flag, gap_flag  2. Operational Constraints (Testable) Parameter Description Values / Limits payload_limit_bytes Maximum UDP application payload 200 bytes reporting_intervals Configurable periodicity of sensor reporting 1s, 5s, 30s (test all) loss_tolerance Must tolerate 5% random loss (no retransmission) Detect but not recover batching Optional; group up to N readings per packet N chosen by your team and justified experimentally   3. Test Scenarios & Acceptance Criteria All tests use Linux netem for network impairment simulation. Each team must provide scripts to automate these tests.  Scenario netem Command Acceptance Criteria 
Baseline  (no impairment) none ≥99% of reports received (1s interval, 60s test); sequence numbers in order. Loss 5% sudo tc qdisc add dev <IF> root netem loss 5% Server detects sequence gaps; duplicate suppression works; duplicate rate ≤1%. Delay + Jitter (100ms ±10ms) sudo tc qdisc add dev <IF> root netem delay 100ms 10ms Server correctly reorders by timestamp; no buffer overrun or crash.   4. Metrics to Collect Each test run should produce the following metrics: Metric Description bytes_per_report Average total bytes (payload + header) per reading packets_received Count of successfully received packets duplicate_rate Fraction of duplicate messages detected sequence_gap_count Number of missing sequences detected cpu_ms_per_report CPU time per reading processed  5. Deliverables Each team must submit the following items: Deliverable Description Mini-RFC (≤3 pages) Formal description of your protocol, including: header table, field sizes, encoding format, message types, batching design, and rationale. Implementation Working client (“sensor”) and server (“collector”) prototypes in C, C++, or Python using UDP sockets. Testing Scripts Automated scripts (e.g., Bash/Python) that run all test scenarios using netem and produce .pcap + .csv outputs. Results & Plots Graphs showing: - bytes_per_report vs reporting_interval  - duplicate_rate vs loss  README Build instructions, usage examples, and a short explanation of your batching decision and field-packing strategy.  Project 2: Multiplayer Game State Synchronization In this project, you will design and implement a custom network protocol to synchronize player positions and ephemeral game events in a simplified multiplayer environment. Your protocol must maintain low-latency synchronization between clients and a central server while tolerating moderate network loss and delay. The focus is on network behavior, not on building a full game — a minimal 2D environment suffices.  1. Functional Requirements 1.1 Core Design Your protocol must: • Use UDP as the transport layer.